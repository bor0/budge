\documentclass{article}

\usepackage{arxiv}

\usepackage{amsmath}
\DeclareMathOperator{\sign}{sign}

% mathbb{N}
\usepackage{amsfonts}

% Phonetic chars
\usepackage{tipa}

\title{The Budge programming language}

\author{
  Boro Sitnikovski \\
  Skopje, North Macedonia \\
  \texttt{buritomath@gmail.com} \\
}

\newcommand\doubleplus{\mathbin{{+}\mspace{-8mu}{+}}}

\begin{document}
\maketitle

\begin{abstract}
We present a simple, esoteric programming language based on Gödel numbering and prime factorization, enhanced with explicit, scoped loops, allowing for easy program composition. We will show the syntax and semantics and then provide a few example programs and their evaluation.
\end{abstract}

\keywords{Programming language, computational model, Gödel numbering}

\section{Introduction}

Budge (b\textturnv\textdyoghlig, b'dzh) is an esoteric programming language. It uses Gödel numbering\cite{b1} to represent registers and their values by relying on the Fundamental Theorem of Arithmetic\cite{b2}. For example, to represent the values $1$, $2$, and $3$ in memory, we would calculate $2^1 \cdot 3^2 \cdot 5^3$ (the first three primes 2, 3, 5 to the power of the number of the value at the corresponding register), arriving at the state $i = 2250$. We can extract $1$, $2$, and $3$ from $2250$ using prime factorization.

Budge uses similar constructs as FRACTRAN\cite{b3}. However, Budge provides a more convenient way to construct loops and uses integers rather than fractions to denote instructions. A negative integer will decrease a register's value, while a positive integer will increase a register's value. In addition, it provides an easy way to code loops by using nested parenthesis\footnote{One disadvantage of the syntax for loops is that programs can't be as easily represented in memory.}. Finally, it abstracts prime numbers in the code from the programmer.

\section{Syntax and semantics}

Where data is represented as $i \in \mathbb{N^+}$ (product of primes), the syntax of the code in Backus-Naur form\cite{b4} is:

\begin{verbatim}
<posn>  ::= "1" | "2" | ...               <negn> ::= "-1" | "-2" | ...
<stmt>  ::= <posn> | <negn> | "("<posn>","<stmts>")"
<stmts> ::= <stmt>","<stmts> | <stmt>     <code> ::= "("<stmts>")"
\end{verbatim}

Let $p(n)$ be the $n$-th prime number. Let $\sign(n) = 1$ if $n>0$ and $-1$ otherwise; this will determine whether we need to multiply or divide. With $\forall x, n_x \in \mathbb{Z} \land n'_x \in \mathbb{Z}$, let $E(i, s)$ represent the evaluation of a sequence $s$ (\texttt{<code>}) for input $i$ be defined by:

$$ E(i, s) = {
\begin{cases}
E(i \cdot p(|n_0|)^{\sign(n_0)}, (n_1, \ldots, n_k)) & s = (n_0, n_1, \ldots, n_k) \land i \cdot p(|n_0|)^{\sign(n_0)} \in \mathbb{N}, \\
E(i, (n_1, \ldots, n_k)) & s = (n_0, n_1, \ldots, n_k) \land i \cdot p(|n_0|)^{\sign(n_0)} \notin \mathbb{N}, \\
E(E(i, (n'_0, \ldots, n'_k)), s) & s = ((P, n'_0, \ldots, n'_k), n_0, \ldots, n_j) \land i \cdot p(|P|)^{-1} \in \mathbb{N}, \\
E(i, (n_0, \ldots, n_j)) & s = ((P, n'_0, \ldots, n'_k), n_0, \ldots, n_j) \land i \cdot p(|P|)^{-1} \notin \mathbb{N}, \\
i & {\text{otherwise, that is, } s = ()}\end{cases}} $$

Semantically, the first case handles increasing/decreasing a value in a register $n_0$. The second case is for skipping an instruction. The third and fourth cases represent the start and end of a loop (nested parenthesis).

\section{Example programs in Budge}

\subsection{Addition of numbers (manual evaluation)}

To compute $E(2^3 \cdot 3^3, ((2, -2, 1)))$ we iterate the sequence $(-2, 1)$ until $\frac{i}{p(2)}$ is no longer an integer, that is, $\frac{i}{3}$:

\begin{enumerate}
\item Initially, $i = 2^3 \cdot 3^3 = 216$, and since $\frac{216}{3} = 72 \in \mathbb{N}$, proceed with evaluation.
\item Calculate $p(|n|)^{\sign(n)}$ for $n = -2$: $i' = p(2)^{-1} = 3^{-1}$. Since $i \cdot i' \in \mathbb{N}$, set $i$ to $i \cdot i' = 216 \cdot i' = 72$.
\item Calculate $p(|n|)^{\sign(n)}$ for $n = 1$: $i' = p(1)^{1} = 2$. Since $i \cdot i' \in \mathbb{N}$, set $i$ to $i \cdot i' = 72 \cdot i' = 144$.
\item At this point, we go back and check the condition if $\frac{144}{3} \in \mathbb{N}$ - proceed with the evaluation.
\item Calculate $p(|n|)^{\sign(n)}$ for $n = -2$: $i' = p(2)^{-1} = 3^{-1}$. Since $i \cdot i' \in \mathbb{N}$, set $i$ to $i \cdot i' = 144 \cdot i' = 48$.
\item Calculate $p(|n|)^{\sign(n)}$ for $n = 1$: $i' = p(1)^{1} = 2$. Since $i \cdot i' \in \mathbb{N}$, set $i$ to $i \cdot i' = 48 \cdot i' = 96$.
\item At this point, we go back and check the condition if $\frac{96}{3} \in \mathbb{N}$ - proceed with the evaluation.
\item Calculate $p(|n|)^{\sign(n)}$ for $n = -2$: $i' = p(2)^{-1} = 3^{-1}$. Since $i \cdot i' \in \mathbb{N}$, set $i$ to $i \cdot i' = 96 \cdot i' = 32$.
\item Calculate $p(|n|)^{\sign(n)}$ for $n = 1$: $i' = p(1)^{1} = 2$. Since $i \cdot i' \in \mathbb{N}$, set $i$ to $i \cdot i' = 32 \cdot i' = 64$.
\item Now we have that $\frac{64}{3} \notin \mathbb{N}$, so the evaluation halts.
\end{enumerate}

Thus, $i$ is now equal to $64 = 2^6$. That is, the value from the first register $p(1)$ and the value from the second register $p(2)$ were added, and then stored in the first register, $p(1)$. In general, $E(2^a \cdot 3^b, ((2, -2, 1))) = 2^n$, with $n = a + b$.

\subsection{Other arithmetic operations}

\textit{Subtraction}: $E(2^x \cdot 3^y, s) = 2^n \cdot 3^k$ where $n = |x - y|$ and $k = 1$ if $y > x$, and $k = 0$ otherwise.

$$s = ((1, -1, 3, 5), (2, -2, 4, 6), (3, -3, -4), (6, -5, -6), (4, -4, 1, 3), (3, (3, -3), 2), (5, -5, 1))$$

\textit{Multiplication}: $E(2^x \cdot 3^y, m) = 2^n$ where $n = x \cdot y$.

$$m = ((1, -1, (2, -2, 3, 4), (4, -4, 2)), (2, -2), (3, -3, 1))$$

\textit{Division}: $E(2^a \cdot 3^d, d) = 2^q \cdot 3^r$ where $a = qd + r$ and $0 \leq r < d$.

\begin{equation*}
\begin{split}
d = (9, (9, (2, -2, 7, 8), (8, -8, 2)) \doubleplus s \doubleplus (3, (2, -2, -3), (3, -3, 2), \\
(9, -9), (2, -2, 9), (7, -7, 2), 10), (1, -1, -2), (10, -10, 1), -1)
\end{split}
\end{equation*}

\section{Composing and interpreting programs}

As we saw with $d$, sequences can be composed by concatenating them: $\forall s_1, \forall s_2, E(E(i, s_1), s_2) = E(i, s_1 \doubleplus s_2)$. For example, the sequence $(1, 2, 2, (2, -2, 1))$ is consisted of concatenating $(1, 2, 2)$ and $((2, -2, 1))$; initialize registers with values 1 and 2 respectively, and then add 1 and 2 together, storing the result in the first register.

We show the pseudo-code representation of this sequence by following its semantical interpretation:

\begin{verbatim}
r1 = 1; r2 = 2; // sequence 1
while (r2 > 0) { r2 -= 1; r1 += 1; } // sequence 2. optimized: r1 += r2; r2 = 0;
\end{verbatim}

\begin{thebibliography}{1}

\bibitem{b1}
Douglas Hofstadter
\newblock {\em Godel, Escher, Bach: an Eternal Golden Braid}
\newblock Basic Books, Inc., 1979.

\bibitem{b2}
Artur Korniłowicz, Piotr Rudnicki
\newblock {\em Fundamental Theorem of Arithmetic}
\newblock Formalized Mathematics 12.2, 2004.

\bibitem{b3}
John H. Conway
\newblock {\em Fractran: A simple universal programming language for arithmetic}
\newblock Open problems in Communication and Computation, 1986.

\bibitem{b4}
Daniel D. McCracken, Edwin D. Reilly
\newblock {\em{Backus-Naur Form (BNF)}}
\newblock Encyclopedia of Computer Science, 2003.

\end{thebibliography}
\end{document}
