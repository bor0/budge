# SKI formal system (object-level), as per https://en.wikipedia.org/wiki/SKI_combinator_calculus

## SKI base terms
rTmS : S
rTmK : K
rTmI : I
rTmE : EPS
tmS! : rTmS
tmK! : rTmK
tmI! : rTmI
tmE! : rTmE

## SKI term construction rules
rTm : (x y)

## SKI derivation rules
# I combinator
rId : ⊢(d (I x)) => ⊢(d x)
rId' : ⊢(I x) => ⊢x # Handling EPS (empty) case
# K combinator, corresponds to Hilbert's r1
rConst : ⊢(d ((K x) y)) => ⊢(d x)
rConst' : ⊢((K x) y) => ⊢x # EPS
# S combinator, corresponds to Hilbert's r2
rSubst : ⊢(d (((S x) y) z)) => ⊢(d ((x z) (y z)))
rSubst' : ⊢(((S x) y) z) => ⊢((x z) (y z)) # EPS

## Modus ponens
rMp : ⊢p -> ⊢(p => q) -> ⊢q
## Hypothetical syllogism
# TODO: This can probably be proved on its own using the previous rules.
# See hilbert.btp `thm2` which uses r1 and r2 which correspond to K and S.
rHs : ⊢a => ⊢b -> ⊢b => ⊢c -> ⊢a => ⊢c

# Terms needed for the proofs
tm(SK)! : rTm x=tmS!;y=tmK!
tm((SK)S)! : rTm x=tm(SK)!;y=tmS!
tm(((SK)S)K)! : rTm x=tm((SK)S)!;y=tmK!
tm(I(((SK)S)K))! : rTm x=tmI!;y=tm(((SK)S)K)!
tm(I(I(((SK)S)K)))! : rTm x=tmI!;y=tm(I(((SK)S)K))!
tm(KK)! : rTm x=tmK!;y=tmK!
tm((KK)(SK))! : rTm x=tm(KK)!;y=tm(SK)!

# Theorems
th=>EgTerm : rId d=tmI!;x=tm(((SK)S)K)!
th=>(((SK)S)K) : rId' x=tm(((SK)S)K)!
th=>KK(SK) : rSubst' x=tmK!;y=tmS!;z=tmK!
th=>K : rConst' x=tmK!;y=tm(SK)!

# Proof
thK'! : rHs a=tm(I(I(((SK)S)K)))!;b=tm(I(((SK)S)K))!;c=tm(((SK)S)K)! th=>EgTerm th=>(((SK)S)K)
thK''! : rHs a=tm(I(I(((SK)S)K)))!;b=tm(((SK)S)K)!;c=tm((KK)(SK))! thK'! th=>KK(SK)
thK : rHs a=tm(I(I(((SK)S)K)))!;b=tm((KK)(SK))!;c=tmK! thK''! th=>K
