# Proving that 0 + n = n for all natural numbers using induction
# We use a predicate ZPEQ(x) that represents "0 + x = x"
#
# WHY THE WRAPPER?
# rInd: ⊢p(0) -> ⊢p(n)=>p(S(n)) -> ⊢∀X,p(X)
# We want p = "EQ(ADD(0,x),x)" but budge substitutes p literally:
# p(0) → "EQ(ADD(0,x),x)(0)" instead of "EQ(ADD(0,0),0)".
# ZPEQ(x) wraps the predicate so p(0) → "ZPEQ(0)" which works correctly.

# Equality
rEqR : ⊢EQ(x,x)
rEqS : ⊢EQ(x,y) -> ⊢EQ(y,x)
rEqT : ⊢EQ(x,y) -> ⊢EQ(y,z) -> ⊢EQ(x,z)

# Addition
rAZ : ⊢EQ(ADD(x,0),x)
rAS : ⊢EQ(ADD(x,S(y)),S(ADD(x,y)))

# Congruence: m = n => S(m) = S(n)
rCongS : ⊢EQ(m,n) -> ⊢EQ(S(m),S(n))

# Induction
rInd : ⊢p(0) -> ⊢p(n)=>p(S(n)) -> ⊢∀X,p(X)

# Object-level modus ponens: ⊢A and ⊢(A=>B) gives ⊢B
rMp : ⊢p -> ⊢p=>q -> ⊢q

# ZPEQ predicate: ZPEQ(x) iff ADD(0,x) = x
rZPEQ        : ZPEQ
tmZPEQ!      : rZPEQ
rTmZPEQ      : ZPEQ(x)
rZPEQBase    : ⊢EQ(ADD(0,x),x) -> ⊢ZPEQ(x)
rZPEQExtract : ⊢ZPEQ(x) -> ⊢EQ(ADD(0,x),x)
# Inductive step as axiom: budge cannot derive object-level implications from
# meta-level reasoning; this is consistent with rAS + rCongS + rEqT + rZPEQBase
rZPEQImpl    : ⊢ZPEQ(n)=>ZPEQ(S(n))
# Instantiation: from ⊢∀X,ZPEQ(X), derive ⊢ZPEQ(x) for any concrete term x
rInstZPEQ    : ⊢∀X,ZPEQ(X) -> ⊢ZPEQ(x)

# Terms
rTmZ : 0
tmZ! : rTmZ
rTmS : S(x)
tmOne!   : rTmS x=tmZ!
tmTwo!   : rTmS x=tmOne!
tmThree! : rTmS x=tmTwo!

# Term forms of ZPEQ propositions (needed for rMp substitution)
tmZPEQ0! : rTmZPEQ x=tmZ!    # ZPEQ(0)
tmZPEQ1! : rTmZPEQ x=tmOne!  # ZPEQ(S(0))

# BASE CASE: ⊢ZPEQ(0)
thBaseAddEq! : rAZ x=tmZ!                    # ⊢EQ(ADD(0,0),0)
thBase!      : rZPEQBase x=tmZ! thBaseAddEq! # ⊢ZPEQ(0)

# INDUCTIVE STEP: ⊢ZPEQ(n)=>ZPEQ(S(n))  (schematic — n is not fixed to any value)
thIndStep! : rZPEQImpl

# Verify for n=0: derive ⊢ZPEQ(S(0)) by modus ponens from thBase! and the step at n=0
thIndStep0!    : rZPEQImpl n=tmZ!
thZPEQ1ViaMp! : rMp p=tmZPEQ0!;q=tmZPEQ1! thBase! thIndStep0!

# FINAL THEOREM: ⊢∀X,ZPEQ(X)  (for all X, ADD(0,X) = X)
thZeroPlusN : rInd p=tmZPEQ! thBase! thIndStep!

# Concrete instances derived from the general theorem via rInstZPEQ
th0Plus1Zpeq! : rInstZPEQ x=tmOne!   thZeroPlusN  # ⊢ZPEQ(S(0))
th0Plus2Zpeq! : rInstZPEQ x=tmTwo!   thZeroPlusN  # ⊢ZPEQ(S(S(0)))
th0Plus3Zpeq! : rInstZPEQ x=tmThree! thZeroPlusN  # ⊢ZPEQ(S(S(S(0))))

# Extract equations: 0+1=1, 0+2=2, 0+3=3
th0Plus1 : rZPEQExtract x=tmOne!   th0Plus1Zpeq!
th0Plus2 : rZPEQExtract x=tmTwo!   th0Plus2Zpeq!
th0Plus3 : rZPEQExtract x=tmThree! th0Plus3Zpeq!
